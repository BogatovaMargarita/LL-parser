## Цели и требования.
Необходимо провести исследование в области нисходящих анализаторов LL(k).

Используя язык программирования С99 необходимо реализовать алгоритм синтаксического анализатора для формальной грамматики вида

`S->B2`

`B->0|1`

## Базовые определения
### Синтаксический анализ и анализатор 
> Синтаксический анализ - способ выяснения для полученной строки терминалов способов ее вывода из стартового символа грамматики.
> 
> Синтаксический анализатор - алгоритм, который организует синтаксический анализ.

Нисходящий синтаксический анализ можно рассматривать как задачу построения дерева разбора для входной строки, начиная с корня и создавая узлы дерева разбора в прямом порядке обхода(в глубину). 

Предиктивный синтаксический анализ  выбирает корректную продукцию путем предпросмотра фиксированного количества символов входной строки. Типичной является ситуация, когда необходимо и достаточно просмотреть только один входной символ. 

**Схема работы синтаксического анализатора**

*Входная лента* представляет собой последовательность ячеек, каждая из которых содержит один символ некоторого конечного алфавита.

*Входная головка* в каждый момент обозревает одну ячейку. За один шаг работы анализатора головка сдвигается на одну ячейку влево (вправо) или остается неподвижной. Синтаксический анализатор, не перемещающий входную головку влево, называется односторонним. 

*Управляющее устройство* – это программа управления синтаксический анализатором. Она задает конечное множество состояний анализатора и определяет переходы из состояния в состояние в зависимости от прочитанного символа входной ленты и содержимого вспомогательной памяти.

*Вспомогательная память* служит для хранения информации, которая зависит от состояния анализатора. У некоторых типов анализаторов она может отсутствовать.

### Понятие контекстно-свободных грамматик и LL(k) грамматик
> *Контекстно-свободной* грамматикой называется грамматика, у которой в левых частях всех правил стоят только одиночные нетерминалы

> Класс грамматик, для которых возможно построить предиктивный синтаксический анализатор, просматривающий k символов во входном потоке называется *классом LL(K)*

Грамматика обладает свойством LL(k), k > 0, если на каждом шаге вывода для однозначного выбора очередной альтернативы анализатору достаточно знать символ на верхушке стека и рассмотреть первые k символов от текущего положения считывающей головки во входной цепочке символов.

*Грамматика называется LL(k)-грамматикой, если она обладает свойством LL(k) для некоторого k > 0.*

Название «LL(k)» несет определенный смысл. Первая литера «L» происходит от слова «left» и означает, что входная цепочка символов читается в направлении слева направо. Вторая литера «L» также происходит от слова «left» и означает, что при работе распознавателя используется левосторонний вывод. 

Для LL(k)-грамматик известны следующие полезные свойства:

* всякая LL(k)-грамматика для любого k>0 является однозначной;
* существует алгоритм, позволяющий проверить, является ли заданная грамматика LL(k)-грамматикой для строго определенного числа k.

Есть, однако, неразрешимые проблемы для произвольных КС-грамматик:

* не существует алгоритма, который бы мог проверить, является ли заданная КС-грамматика LL(k)-грамматикой для некоторого произвольного числа k;
* не существует алгоритма, который бы мог преобразовать произвольную КС-грамматику к виду LL(k)-грамматики для некоторого k (или доказать, что преобразование невозможно).

Это несколько ограничивает применимость LL(k)-грамматик, поскольку не всегда для произвольной КС-грамматики можно очевидно найти число k, для которого она является LL(k)-грамматикой, или узнать, существует ли вообще для нее такое число k.
Для LL(k)-грамматики при k>1 совсем не обязательно, чтобы все правые части правил грамматики для каждого нетерминального символа начинались с k различных терминальных символов.

Поскольку все LL(k)-грамматики используют левосторонний нисходящий распознаватель, основанный на алгоритме с подбором альтернатив, очевидно, что они не могут допускать левую рекурсию. Поэтому никакая леворекурсивная грамматика не может быть LL-грамматикой. Следовательно, первым делом при попытке преобразовать грамматику к виду LL-грамматики необходимо устранить в ней левую рекурсию.

### Понятие множеств FIRST(1,a) и FOLLOW(a)
При построении нисходящего анализатора необходимо реализовать функции `FIRST`  и `FOLLOW`, которые позволяют выбрать применяемую продукцию на основании очередного символа входного потока.  

* `FIRST(k, а)` — множество терминальных цепочек, выводимых из терминалов и нетерминалов грамматики, укороченных до k символов;
* `FOLLOW(k, а)` — множество укороченных до k символов терминальных цепочек, которые могут следовать непосредственно за некоторым нетерминалом в цепочках вывода

То есть, в случае k = 1, `FIRST(1, а) `- множество терминалов, которые могут появляться в качестве первого символа одной или нескольких строк, сгенерированных из a; где а - строка, состоящая из терминалов и нетерминалов. Если а начинается с терминала, то он является единственным в множестве, если же с нетерминала, продукции которого начинаются с терминалов - они и будут содержимом множества. `FOLLOW(1, a)` - множество терминалов, которые могут располагается непосредственно справа от а

## LL(1) грамматики и анализатор, ограничения 
*LL(1) анализатор* - нисходящий анализатор грамматик, принадлежащих классу LL(1), которому для определения пути разбора необходима всего одна лексема входной строки. Очень быстр в исполнении и имеет характерное сообщение об ошибке вида «ожидался такой-то символ».

**Условие принадлежности некоторой грамматики G к классу LL(1)**

Для любых двух различных продукций грамматики G `A->a|b` выполняется

1. Не существует такого терминала, для которого и `a` и `b` порождают строку, начинающуюся с него. Другими словами для каждого нетерминального символа не может быть двух правил, начинающихся с одного и того же терминального символа.
2. Пустую строку может порождать не более чем одна из продукций `a` или `b`
3. Если `b` порождает пустую строку, то а не порождает ни одну строку, начинающуюся с терминала из `FOLLOW(A)`

Перечисленные выше условия можно отнести к требованию однозначности рассматриваемого класса грамматик. Также, как уже было сказано выше, в грамматиках класса LL(k) должна отсутствовать левая рекурсия. 

Условия отсутствия неоднозначности и левой рекурсии, накладываемые на правила LL(1)-грамматик, являются довольно жесткими. 0чень немногие реальные грамматики могут быть отнесены к классу LL(1)-грамматик. Ниже приведены примеры "плохих" грамматик и возникающие при анализе конфликты.

**1.FIRST/FIRST конфликт**

Множество FIRST двух различных правил грамматики для одного и того же нетерминала пересекаются. 

	     S -> E | E 'a'
	     E -> 'b' | ε

`FIRST(E) = {'b', ε}` и `FIRST(E 'a') = {'b', 'a'}`, при построении таблицы синтаксического анализа возникает неоднозначность в поле `[S,b]`

**2.Левая рекурсия**
   
	 Е -> E '+' term | alt1 | alt2


**3.FIRST/FOLLOW конфликт.**

Пересечение множеств FIRST и FOLLOW

     S -> A 'a' 'b'
     A -> 'a' | ε

`FIRST(A)= {'a', ε}` и `FOLLOW(А)={'a'}`

Благо, существуют алгоритмы, с помощью которых можно попробовать преобразовать правила грамматики и привести ее к виду LL(1): алгоритм устранения левой рекурсии и алгоритм левой факторизации. Однако применение этих двух преобразований отнюдь не гарантирует, что произвольную КС-грамматику удастся привести к виду LL(1)-грамматики.
## Выполнение практической части
### Условия и ограничения 
Запишем характеристики данной формальной грамматики в более точной формулировке

* Терминальные символы: {0, 1, 2}
* Нетерминальные символы: {S, B}
* Стартовый символ `S`
* Продукции:

	1. `S->B2`

	2. `B->0|1`

Данная грамматика является контекстно-свободной(левая часть продукций состоит из одного нетерминального символа) и принадлежит классу LL(1) грамматик.
Можно заметить, что для такой грамматики возможно лишь 2 дерева вывода, следовательно, мощность множества слов, которые можно построить с помощью продукций грамматики равняется двум: {02,12}
### Структура хранения грамматики
В качестве структуры хранения грамматики я выбрала хеш-таблицы с несколько измененным механизмом вставки. 

* **Запись в таблице. Структура `Record`**

Для каждого нетерминала необходимо хранить все его продукции. Для того, чтобы не нужно было парсить большую строку с продукциями при необходимости доступа к ним, считаю целесообразным в качестве записи использовать структуру со следующими полями

		void** value;
		int countValue;
		char key;

Под void** в интерпретации продукций грамматики понимается двумерный массив строк, где каждая строка - отдельная продукция нетерминала, хранящегося как `key`.
 
* **Таблица с хеш-размещением**
Выбор пал на хеш-таблицы из-за того, что они отражают концепцию доступа к данным через содержимое этих данных, что является крайне полезным при необходимости быстрого получения продукций некоторого нетерминала. В качестве способа решения коллизий выбран способ линейного закрытого хеширования.
* **Функция вставки `InsRecordTab`**
Особенность состоит в том, что при добавлении в таблицу элемента с уже существующим ключом, ошибки не возникает, и значение добавляется в качестве новой строки двумерного массива.
### Алгоритм построения множества FIRST(1,a) 
* Обозначим множество нетерминалов через N, терминалов через T.

Описание стандартного алгоритма построения множества `FIRST(1, A)`.

**Шаг 1.** Первоначально внести во множество `FIRST` для каждого нетерминального символа А все символы, стоящие в начале правых частей правил для этого нетерминала

**Шаг 2.** Для всех нетерминалов A принадлежащих N положить:

`FIRSTi+1(1, A) = FIRSTi(1, A) <объединение> FIRSTi(1, B)`

где под В понимается каждый нетерминал, принадлежащий множеству `FIRSTi(1, A)`

**Шаг 3.** Если существует нетерминал А, принадлежащий N, такой что `FIRSTi+1(1, A) != FIRSTi(1, A)` то присвоить `i=i+1` и вернуться к шагу 2, иначе перейти к шагу 4.

**Шаг 4.** Исключить из построенных множеств все нетерминальные символы.

Представленный выше алгоритм не использует дополнительной памяти, но при этом является не оптимальным по времени из-за следующих причин. *Во первых*, для выполнения шага 2 необходима операция объединения множеств, которая имеет высокую сложность О(N^2). *Во вторых,* на шаге 3 необходимо сравнение множеств, что тоже требует прохода по обоим множествам. И на шаге 4 также осуществляется проход по всем сформированным множествам.

Предполагаю, что наивная реализация алгоритма выше будет не оптимальной.
Один из способов оптимизировать работу алгоритма - использование дополнительной памяти. В моей реализации это 2 массива:

		char** waiting = calloc(2, sizeof(char*));
		bool* ready = calloc(g->countNterm, sizeof(bool));

Двумерный массив `waiting` хранит пары нетерминалов: `<Нетерминал1><Нетерминал2>`, где `Нетерминал1` ждет готовности `Нетерминала2`, то есть наличия в множестве этого нетерминала некоторой терминальной строки и отсутствия его в качестве "ждущего нетерминала" в других парах. 
Формируются эти пары по принципу `FIRST(<Нетерминал1>)=...<Нетерминал2>...` . Это поможет избежать многократного прохода по "уже собранным множествам". Также вводится двумерный массив флагов `ready`, каждый i-й элемент которого сообщает, собрано ли множество FIRST для нетерминала i.

При первом проходе по продукциям нетерминалов формируется массив `waiting` и в множества заносятся терминалы. При последующем проходе по массиву `waiting`, в бесконечном цикле, множества "ждущих" нетерминалов заполняются за счет уже сформированных. При успешной обработке пара в массиве `waiting` не удаляeтся, а маркируются. Выход из цикла происходит в там случае, когда все элементы из `waiting` замаркироаны. Стоит отметить, что приведенное решение является не вполне оптимальным, так как количество итераций по массиву `waiting` зависит от того, в каком порядке пары расположены в массиве.
### Алгоритм построения множества FOLLOW(а)
Общее описание алгоритма: 

**Шаг 1.** Первоначально внести во множество последующих символов для каждого нетерминального символа `А` все символы, которые в правых частях правил вывода встречаются непосредственно за символом `А`

**Шаг 2.** Внести '$' во множество `FOLLOW(1, S)`, где `S`  стартовый символ

**Шаг 3.** Для всех нетерминалов `A` принадлежащих N вычислить:

`FOLLOW'i(1,A)=FOLLOWi(1,A)<объединение>FIRST(1,B)`

где под `В` понимается каждый нетерминал, принадлежащий множеству `FIRSTi(1, A)`.

**Шаг 4.** Для всех нетерминалов `A` принадлежащих N положить:

`FOLLOW''i(1, A)=FOLLOW'i(1, A)<объединение>FOLLOW'i(1, B)`

где под `В` понимается каждый нетерминал, принадлежащий множеству `FOLLOW'i(1, A)` или же `В` порождает пустую строку.

**Шаг 5.** Для всех нетерминалов `A` принадлежащих определить:

`FOLLOWi+1(1, A) = FOLLOW''i(1, A)<объединение>FOLLOW''i(1, B)`

для всех нетерминальных символов `B`, имеющих правило вида 
`B->aA`.

**Шаг 6.** Если существует нетерминал A такой, что `FOLLOWi+1(1,A)!=FOLLOWi(1,A)`, то положить `i:=i+1` и вернуться к шагу 3, иначе перейти к шагу 7.

**Шаг 7.** Исключить из построенных множеств все нетерминальные символы

Этот алгоритм также требует многократныx проходов как по продукциям, так и по множествам. В его реализации я  так же делаю выбор в пользу использования дополнительной памяти и определяю 2 дополнительных массива и переменную-флаг.

		bool flag = true;
		bool* changed = calloc(g->countNterm, sizeof(bool));
		char** waiting = calloc(2, sizeof(char*));

Уже знакомый массив `waiting`, который идентичен массиву, использовавшемуся при построении множества `FIRST`, за исключением правил, по которым он формируется.
Массив `changed` используется дли индикации изменения соответствующего множества на текущей итерации.
`Переменная-флаг` необходима, чтобы отловить ситуацию, когда множества уже не изменяются и алгоритм закончил свою работу.

При первом проходе по продукциям нетерминалов формируется массив `waiting` и в множества `FOLLOW` заносятся необходимые множества FIRST. Далее мы проходим по массиву "ожидающих", пока в течении итерации будет хотя бы одно изменение какого то множества. При успешной обработке пара в массиве `waiting` не удаляeтся, а маркируются.

### Структура хранения таблицы синтаксического анализа
В качестве структуры хранения я выбрала уже реализованную хеш-таблицу. Но в данном случае нам требуется двумерная хеш-таблица. И тут в игру вступает `void**`, с помощью которого становится возможным организовать хеш-таблицу хеш-таблиц.
То есть, существует основная хеш-таблица, запись в которой это ключ(нетерминал) и указатель на хеш таблицу с терминалами в качестве ключей и продукциями в качестве записей. 

Возможно, что такая сложность здесь ни к чему. Но все таки, при организации структуры хранения я отталкивалась от идеи быстрого доступа к данным.
### Алгоритм построения таблицы синтаксического анализа
**Вход:** КС-грамматика `G = (N, T, P, S)`.

**Выход:** таблица `M[A, a]` предсказывающего анализатора.

**Метод:** для каждого правила вывода A->a грамматики выполнить шаги 1 и 2. После этого выполнить шаг 3.

1. Для каждого терминала `n` из `FIRST(a)` добавить `A->a` к `M[A, n]`.
2. Если пустая строка принадлежит `FIRST(a)`, добавить `A->a` к `M[A, b]` для каждого терминала `b` из `FOLLOW(A)`. Кроме того, если пустая строка принадлежит `FIRST(а)` и $ принадлежит  `FOLLOW(A)`, добавить `A->a ` к `M[A, $]`.
3. Положить все неопределенные входы равными `ошибка`.

### Алгоритм нерекурсивного предиктивного синтаксического анализа
**Вход:** строка `w` и таблица синтаксического анализа `М` для грамматики `G`

**Выход:** если строка выводится из данной грамматики, то true, иначе false

**Метод:** изначально синтаксический анализатор находится в конфигурации с `w$` во входном буфере и стартовым символом на вершине стека, над элементом $.

**Шаг 1.** Помещаем в стек $ и начальный символ грамматики S, а во входной буфер исходную цепочку символов. Устанавливаем указатель входного потока на первый символ.

**Шаг 2.** До тех пор пока в стеке и во входном буфере останется только пустая строка либо будет обнаружена ошибка в алгоритме разбора, выполняем одно из следующих действий:

-   устанавливаем `а` равным символу, на который указывает указатель входного потока.
-  	если на верхушке стека находится терминальный символ `а`, совпадающий с очередным символом входной строки, то удаляем из стека этот символ и передвигаем вправо указатель входного потока;
-  	если на верхушке стека находится терминальный символ, не совпадающий с символом из входного потока, то выводим сообщение об ошибке
-	если на верхушке стека находится нетерминальный символ `X` и `М[X,a]` - запись об ошибке, то выводим сообщение об ошибке
-	если на верхушке стека находится нетерминальный символ `X` и `М[X,a]` не ошибка,  то извлекаем из стека символ А и заносим в стек строку из таблицы  `М[X,a]`, не меняя содержимого входного буфера;
-	если содержимое стека и входного буфера пусто, то исходная строка прочитана полностью, и разбор завершен удачно;
-	если ни одно из данных условий не выполнено, то цепочка не принадлежит заданному языку, и алгоритм завершает свою работу с ошибкой.

Этот алгоритм легко реализуется с учетом выбранных структур хранения и разработанных алгоритмов.
### Реализация
Код практического задания находится в репозитории.

* `include`  - заголовочные файлы
* `src` - файлы исходного кода
### Возможная модернизация
* Стоит подумать над реализацией структур хранения продукций нетерминалов и таблицы синтаксического анализа.
* Возможно, есть алгоритм построения множеств без использования такого большого количества дополнительной памяти
* Стоит сделать проект более общим, c возможностью задания грамматики пользователем, внести алгоритмы левой факторизации и устранения левой рекурсии.
## Вывод
Класс LL-грамматик широк, но все же он недостаточен для того, чтобы покрыть все возможные синтаксические конструкции в языках программирования. Однако LL-грамматики удобны для использования, поскольку позволяют построить синтаксические анализаторы с линейными характеристиками (линейной зависимостью требуемых для работы алгоритма распознавания вычислительных ресурсов от длины входной цепочки символов).
## Литература и интернет источники
1. Ахо, Сети, Ульман, «Компиляторы. Принципы, технологии, инструменты»
2. https://en.wikipedia.org/wiki/LL_parser
3. http://www.math.spbu.ru/user/mbk/PDF/Ch-11.pdf
4. https://studfiles.net/preview/4599410/