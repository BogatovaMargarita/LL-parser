##Цели и требования.
Необходимо провести исследование в области нисходящих анализаторов 

Используя язык программирования С99 необходимо реализовать алгоритм синтаксического анализатора для формальной грамматики вида

`S->B"2"`

`B->"0"|"1"`

##Базовые определения
###Синтаксический анализ и анализатор 
> Синтаксический анализ - способ выяснения для полученной строки терминалов способов ее вывода из стартового символа грамматики
> Синтаксический анализатор - алгоритм, который организует синтаксический анализ

Нисходящий синтаксический анализ можно рассматривать как задачу построения дерева разбора для входной строки , начиная с корня и создавая узлы дерева разбора в прямом порядке обхода(в глубину). 
Предиктивный синтаксический анализ  выбирает корректную продукцию путем предпросмотра фиксированного количества символов входной строки. Типичной является ситуация, когда необходимо и достаточно просмотреть только один входной символ. 

**Схема работы синтаксического анализатора**

*Входная лента* представляет собой последовательность ячеек, каждая из которых содержит один символ некоторого конечного алфавита.

*Входная головка* в каждый момент обозревает одну ячейку. За один шаг работы анализатора головка сдвигается на одну ячейку влево (вправо) или остается неподвижной. Синтаксический анализатор, не перемещающий входную головку влево, называется односторонним. 

*Управляющее устройство* – это программа управления синтаксический анализатором. Она задает конечное множество состояний анализатора и определяет переходы из состояния в состояние в зависимости от прочитанного символа входной ленты и содержимого вспомогательной памяти.

*Вспомогательная память* служит для хранения информации, которая зависит от состояния анализатора. У некоторых типов анализаторов она может отсутствовать.

###Понятие контекстно-свободных грамматик и LL(k) грамматик
> Контекстно-свободной грамматикой называется грамматика, у которой в левых частях всех правил стоят только одиночные нетерминалы

> Класс грамматик, для которых достаточно построить предиктивный синтаксический анализатор, просматривающий k символов во сходном потоке называется классом LL(K)

Другими словами, LL(k)-грамматики- класс грамматик, основанный именно на принципе выбора одной альтернативы из множества возможных на основе нескольких очередных символов в цепочке.

Грамматика обладает свойством LL(k), k > 0, если на каждом шаге вывода для однозначного выбора очередной альтернативы анализатору достаточно знать символ на верхушке стека и рассмотреть первые k символов от текущего положения считывающей головки во входной цепочке символов.
Грамматика называется LL(k)-грамматикой, если она обладает свойством LL(k) для некоторого k > 0.

Название «LL(k)» несет определенный смысл. Первая литера «L» происходит от слова «left» и означает, что входная цепочка символов читается в направлении слева направо. Вторая литера «L» также происходит от слова «left» и означает, что при работе распознавателя используется левосторонний вывод. 

Для LL(k)-грамматик известны следующие полезные свойства:

* всякая LL(k)-грамматика для любого k>0 является однозначной;
* существует алгоритм, позволяющий проверить, является ли заданная грамматика LL(k)-грамматикой для строго определенного числа k.

Есть, однако, неразрешимые проблемы для произвольных КС-грамматик:

* не существует алгоритма, который бы мог проверить, является ли заданная КС-грамматика LL(k)-грамматикой для некоторого произвольного числа k;
* не существует алгоритма, который бы мог преобразовать произвольную КС-грамматику к виду LL(k)-грамматики для некоторого k (или доказать, что преобразование невозможно).

Это несколько ограничивает применимость LL(k)-грамматик, поскольку не всегда для произвольной КС-грамматики можно очевидно найти число k, для которого она является LL(k)-грамматикой, или узнать, существует ли вообще для нее такое число k.
Для LL(k)-грамматики при k>1 совсем не обязательно, чтобы все правые части правил грамматики для каждого нетерминального символа начинались с k различных терминальных символов.

Поскольку все LL(k)-грамматики используют левосторонний нисходящий рас познаватель, основанный на алгоритме с подбором альтернатив, очевидно, что они не могут допускать левую рекурсию. Поэтому никакая леворекурсивная грамматика не может быть LL-грамматикой. Следовательно, первым делом при попытке преобразовать грамматику к виду LL-грамматики необходимо устранить в ней левую рекурсию.

Класс LL-грамматик широк, но все же он недостаточен для того, чтобы покрыть все возможные синтаксические конструкции в языках программирования. Однако LL-грамматики удобны для использования, поскольку позволяют построить распознаватели с линейными характеристиками (линейной зависимостью требуемых для работы алгоритма распознавания вычислительных ресурсов от длины входной цепочки символов).

###Понятие множеств FIRST(1,a) и FOLLOW(a)
При построении нисходящего анализатора необходимо реализовать функции FIRST  и FOLLOW, которые позволяют выбрать применяемую продукцию на основанииочередного символа входного потока.  

* FIRST(k, A) — множество терминальных цепочек, выводимых из терминалов и нетерминалов грамматики, укороченных до k символов;
* FOLLOW(k, A) — множество укороченных до k символов терминальных цепочек, которые могут следовать непосредственно за некоторым нетерминалом в цепочках вывода

То есть, в случае k=1, FIRST(1, а) - множество терминалов, которые могут появляться в качестве первого символа одной или нескольких строк, сгенерированных из a; где а - строка, состоящая из терминалов и нетерминалов. Если а начинается с терминала, то он является единственным в множестве, если же с нетерминала, продукции которого начинаются с терминалов(они и будут содержимом множества). FOLLOW(1, a) - множество терминалов, которые могут располагать сянепосредственно справа от а

##LL(1) грамматики и анализатор, ограничения 
LL(1) анализатор - нисходящий анализатор грамматик, принадлежащих классу LL(1)-грамматик, которому для определения пути разбора необходима всего одна лексема входной строки. Очень быстр в исполнении и имеет характерное сообщение об ошибке вида «ожидался такой-то символ».

**Условие принадлежности некоторой грамматики G к классу LL(1)**

Для любых двух различных продукций грамматики G A->a|b выполняется

1. Не существует такого терминала, для которого и a и b порождают строку, начинающуюся с него. Другими словами для каждого нетерминального символа не может быть двух правил, начинающихся с одного и того же терминального символа.
2. Пустую строку может порождать не более чем одна из продукций a или b
3. Если b порождает пустую строку, то а не порождает ни одну строку, начинающуюся с терминала из FOLLOW(A)

Перечисленные выше условия можно отнести к требованию однозначности рассматриваемого класса грамматик. Также, как уже было сказано выше, в грамматиках класса LL(k) должна отсутствовать левая рекурсия. 

Условия отсутствия неоднозначности и левой рекурсии, накладываемые на правила LL(1)-грамматики, являются довольно жесткими. 0чень немногие реальные грамматики могут быть отнесены к классу LL(1)-грамматик. Ниже приведены примеры "плохих" грамматик и возникающие при анализе конфликты.

**1.FIRST/FIRST конфликт**

Множество FIRST двух различных правил грамматики для одного и того же нетерминала пересекаются. 

	     S -> E | E 'a'
	     E -> 'b' | ε

FIRST(E) = {'b', ε} и FIRST(E 'a') = {'b', 'a'}, при построении таблицы синтаксического анализа возникает неоднозначность в поле [S,b]

**2.Левая рекурсия**
   
	 Е -> E '+' term | alt1 | alt2


**3.FIRST/FOLLOW конфликт.**

Пересечение множеств FIRST и FOLLOW

     S -> A 'a' 'b'
     A -> 'a' | ε

FIRST(A)= {'a', ε} и FOLLOW(А)={'a'}

Благо, существуют алгоритмы, с помощью которых можно попробовать преобразовать правила грамматики и привести ее к виду LL(1): алгоритм устранения левой рекурсии и алгоритм левой факторизации. Однако применение этих двух преобразований отнюдь не гарантирует, что произвольную КС-грамматику удастся привести к виду LL(1)-грамматики.
##Выполнение практической части
###Структура хранения грамматики
###Ограничения и допущения
Запишем характеристики данной формальной грамматики в более точной формулировке

* Терминальные символы: {0, 1, 2}
* Нетерминальные символы: {S, B}
* Продукции:

	1. `S->B2`

	2. `B->0|1`

Данная грамматика является контекстно-свободной(левая часть продукций состоит из одного нетерминального символа) и принадлежит классу LL(k) грамматик.
Можно заметить, что для такой грамматики возможно лишь 2 дерева вывода, следовательно, мощность множества слов, которые можно построить с помощью продукций грамматики равняется двум: {02,12}
###Алгоритм построения множества FIRST(1,a) 
###Алгоритм построения множества FOLLOW(а)
###Структура хранения таблицы синтаксического анализа
###Алгоритм построения таблицы синтаксического анализа
###Алгоритм нерекурсивного предиктивного синтаксического анализа
###Возможная модернизация
##Вывод
##Литература и интернет источники
1. Ахо, Сети, Ульман, «Компиляторы. Принципы, технологии, инструменты»
2. https://en.wikipedia.org/wiki/LL_parser
3. http://www.math.spbu.ru/user/mbk/PDF/Ch-11.pdf
4. https://studfiles.net/preview/4599410/